<SaveAreaView></SaveAreaView> - Распологает элементы так чтобы
их было видно и ничего их не закрывало например челка на телефоне

<Text>Текст {'\n'} тут</Text> - пишет текст, \n перевод на новую строку

Атрибут numberOfLines={1} - обрезает все что выходит за одну стороку

<Text onPress={() => console.log('text pressed')}>Тут текст</Text> - отображает 
текст и отслеживает его нажатие а при нажатии активирует функцию внутри скобок

Атрибут onPress={() => console.log('text pressed')} - позволяет актривировать
функцию по нажатию, здесь я запихнул функцию прям в атрибут, а это дурной тон 
лучше написать функцию в отдельной константе и указать на неё ссылку

Например:
const handTextPress = () => console.log('text pressed')
<Text onPress={handTextPress}>Тут текст</Text>

Тег <Button title='нажми на меня' color="red" onPress={handTextPress}/> - это кнопка с красной
надписью "Нажми на меня" 

alert('Example); - это всплывающие окно показывающее надпись Example

Тег:
<Image /> - Отображает изображение и позоляет его настраивать
Например укажем путь к локальному файлу у нас на проекте:
<Image sourse={require('путь к файлу')}/> sourse указывает путь к картинке в проекте

Но можно указать картинку из всемирной паутины и настроить её:
<TouchableWithoutFeedback onPress={Тут функция}> 
    <Image blurRadius={10} sourse={{
        width: 200,
        height: 150,
       uri: "https://vk.com/doc477447540_618424854?hash=8b44fd140e6ef8be7e&dl=b4b845893c7515f992"
    }}/> 
<TouchableWithoutFeedback/> - blurRadius={10} добовляет расплывчатость, я обернул Image в TouchableWithoutFeedback
чтобы отследить нажатие на него, с изображениями onPress плохо работает

Отличная тема позволяет отследить нажатие на кнопку (Если юзать OnPress{handleButtonPress} на кнопке)
да и еще при нажатии выводить сообщение с загаловком "You pressed the button" и 
основным текстом "Main massage" ТАК И ЭТОГО МНЕ ОКАЗАЛОСЬ МАЛО! и так я добовил массив с двумя 
объектами-кнопками "Да" и "Отмена" и ТУДА я еще приклеил onPress который выводит в консоль
сообщение каккую кнопку я нажал:) Круто! да? 

const handleButtonPress = () => Alert.alert("You pressed the button", "Main massage", [
    { text: "Да", onPress: () => console.log("Вы нажали: Да") },
    { text: "Отмена", onPress: () => console.log("Вы нажали: Отмена") },
  ]);

    А вот и сама кнопка:
    <Button title={"Кнопка"} color="red" onPress={handleButtonPress} /> 


Стили можно тупо через константу писать а не через метод StyleSheet.create
но если мы опечатаемся в написании стиля он все равно это отобразить только так
будто этого стиля нет, а метод StyleSheet.create имеет валидатор который выдает ошибку 
при опечатках - легче искать ошибки

<Text style={simpleStyle} numberOfLines={10}>
const simpleStyle = { backgroundColor: 'red', color: 'white' };

Ширина (width) если указывать в числах то без кавычек
width: 200, - 200 пикселей
А если в процентах то это будет строка, а не число и надо поставить это в кавычки
width: '50%',
Также и с height

opacity: 0.5, - прозрачность 0.5

borderWidth: 2, - ширина обвотки
borderColor: 'red', цвет обвотки
borderStyle: 'dotted', - тип обвотки точки


justifyContent: 'space-around' - блоки будут распологаться так: | [] [] [] |
justifyContent: 'space-between' - блоки будут распологаться так:|[] [] []|
Относительное позиционирование - перемещение элемента относительно его изначальной позиции
top: 10, - на 10 пикселей вниз
top: -10, - на 10 пикселей вверх
left: 10,- на 10 пикселей вправо
left: -10, - на 10 пикселей влево
НЕТ я не ошибся оно так и есть

Абсолютное позиционирование - перемещение элемента относительно нулевых координат самого смартфона
Провернуть такое можно если добавить position: 'absolute', к стилям обьекта и тогда можно
указать при помощи top или left куда его сместить и на сколько

Можно указать на сколько сместить элемент на разных OC:
Подключаем Platform
И вместо 
top: 100,
Мы указываем так
top: Platform.OS === 'ios' ? 150 : 30, - если приложние запущено на айфоне то 150 пикселей
а если на аддройде то 30 пикселей также проверить можно и на другие устроиства телевизоры
или планшеты

Platform.OS === 'ios' можно использовать и для условия (if) для выборочного использования компонентов:
if(Platform.OS === 'ios') {
  return (
    <Text>IOS</Text>
  );
} else {
  return (
    <Text>Android</Text>
  )
}
  
alignItems - Клеишь к родительскому элементу  и он диктует всем дочерним как им расположиться
а если хочешь конкретному элементу указать расположение то прям к нему добавь свойство
alignSelf
Например:
export default function App() {
  return (
    <SafeAreaView style={styles.mainBlock}>
      <View style={[styles.box, { backgroundColor: 'white' }]}></View>
      <View style={[styles.box, { backgroundColor: 'blue', height: 200 }]}></View>
      <View style={[styles.box, { backgroundColor: 'red' }]}></View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  mainBlock: {
    flex: 1,
    backgroundColor: 'black',
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'baseline',
  },
  box: {
    width: 100,
    height: 100,
  },
});

textAlign: "center", - устанавливает текст по центру в блоке

----------------------------------------------------------------------------
РАЗБЕРИ ЭТОТ КОД ТУТ ТЫ ДЕЛАЛ СПИСОК ДЕЛ
import { StatusBar } from "expo-status-bar";
import React, { useState } from "react";
import { View, StyleSheet, Text, FlatList } from "react-native";
import Header from "./components/Header";
import ListItem from "./components/ListItem";

export default function App() {
  const [listOfItems, setListOfItems] = useState([
    { text: "Обрести свободу", index: 1 },
    { text: "Обрести независимость", index: 2 },
    { text: "Стать миллионером", index: 3 },
    { text: "Купить молоко", index: 4 },
  ]);

  return (
    <View style={styles.main}>
      <Header />
      <View>
        <FlatList
          data={listOfItems}
          renderItem={({ item }) => <ListItem el={item} />}
        />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  main: {},
});
-----------------------------------------------------------------------
--border--
borderWidth: 1, - добавляет границы (Обвотка)
<TextInput style={style.input} onChangeText={onChange} placegolder='Что будем делать?'></TextInput>
- placegolder='Что будем делать?' - текст подсказка в поле ввода

//Список возможных вариантов реализации обвотки
borderColor string
borderTopColor string
borderRightColor string
borderBottomColor string
borderLeftColor string
borderRadius number
borderTopLeftRadius number
borderTopRightRadius number
borderBottomLeftRadius number
borderBottomRightRadius number
borderStyle enum('solid', 'dotted', 'dashed') // borderStyle: "solid", - вот так правильно
borderWidth number
borderTopWidth number
borderRightWidth number
borderBottomWidth number
borderLeftWidth number


--keyframe(Анимация)--
import { Keyframe } from 'react-native-reanimated'; - импортируй keyframe
И запиши его в константу (синтаксис схож с StyleSheet)

Пример:
import { Keyframe } from 'react-native-reanimated'; - 
react-native-reanimated небыло и поэтому выдовало ошибку 
пришлось скачивать при помощи команды npm i react-native-reanimated


const keyframe = new Keyframe({
    0: {
      transform: [{ rotate: '0deg' }],
    },
    100: {
      transform: [{ rotate: '45deg' }],
    },
  }
Вместо того чтобы использовать 0 и  100 можно определить краевые точки,
используя from и to ключевые слова. Результат будет таким же.
Но в варианте с числами можно добавить средние значения (от 2 до 99) 
и стилизовать блок по своему конкретно в данный момент времени

БОЛЬШОЙ пример:
export function KeyframeAnimation(): React.ReactElement {
  const [show, setShow] = useState(false);

  const enteringAnimation = new Keyframe({
    0: {
      originX: 50,
      transform: [{ rotate: '45deg' }],
    },
    30: {
      originX: 10,
      transform: [{ rotate: '-90deg' }],
    },
    100: {
      originX: 0,
      transform: [{ rotate: '0deg' }],
      easing: Easing.quad,
    },
  }).duration(2000);   // видимо время анимации

  const exitingAnimation = new Keyframe({
    0: {
      opacity: 1,
      transform: [{ skewX: '0deg' }],
    },
    30: {
      opacity: 0.5,
      transform: [{ skewX: '40deg' }],
      easing: Easing.exp,
    },
    100: {
      opacity: 0,
      transform: [{ skewX: '-10deg' }],
    },
  }).duration(2000);
  
  return (
    <View style={{ flexDirection: 'column-reverse' }}>
      <Button
        title="animate"
        onPress={() => {
          setShow((last) => !last);
        }}
      />
      <View
        style={{ height: 400, alignItems: 'center', justifyContent: 'center' }}>
        {show && (
            <Animated.View
              entering={enteringAnimation}
              exiting={exitingAnimation}
              style={{
                height: 100,
                width: 200,
                backgroundColor: 'blue',
                alignItems: 'center',
                justifyContent: 'center',
              }}
            />
        )}
      </View>
    </View>
  );
}










---------------------------------------------------------------------------------
Дополнительный курс
HTML        -   React Native
<div></div> -   <View></View>
<p></p>     -   <Text></Text>
<img>       -   <Image />
<button />  -   <Button />

Паттерн проектирования Model-View-Controller (MVC) - 
Это способ разделения данных приложения, интерфейса и управляющей логики
на три отдельных компонента(модель, представление, контроллер) для независимой
модернизации этих компонентов
Представление(View) - отвечает за отображение данных модели пользователю, например: слайдер,
Модель(Model) - по сути шкаф с данными(Например: JSON) изменяемыми по команде контроллера,
Контроллер(Controller) - восьмирукий осьминог манипулирующий данными и представлением 
интерпретируя действия пользователя.

Подключение стиля в компонент:
<View style={styles.container}></View> и да "style={styles.container}" можно вставить 
в большинство компонентов

const style = StyleSheet.create({
  Container: {
    // Стили
  },
})

В офицальной документации к React Native можно посмотреть все доступные стили к 
определённому компоненту https://reactnative.dev/docs/view-style-props#backgroundcolor
но это какое-то полотно
https://github.com/vhpoet/react-native-styling-cheat-sheet - вот парень
запилил нормальный гайд по стилям


View стили:
backfaceVisibility: hidden, - применяеться для сокрытия задней
стороны какого либо контейнера при анимации
Значения hidden, visible